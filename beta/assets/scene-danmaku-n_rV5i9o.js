import{g as W,t as E,S as J,c as K,R as T,A as N,a as V,C as Q,p as U,b as Z,d as g}from"./utility-CjXVDNSm.js";import{p as S}from"./scene-previews.module-Bgk_TgTA.js";class X{#e;#a;#t;#n;#s;constructor(e,t,s,n){this.#e=[{start:0,size:e,inuse:!1}],this.#a=t,this.#t=s,this.#n=n,this.#s=0}allocate(e,t,s){const[n,o]=(()=>{for(const[w,r]of this.#e.entries()){if(r.size<e)continue;if(!r.inuse)return[w,r];const _=Math.min(t,r.user_speed)*this.#a,p=r.user_speed*(s-r.user_enter_time-this.#t);if(t<=r.user_speed&&p<=_)continue;const x=r.user_enter_time+this.#t+this.#n/r.user_speed,m=t-r.user_speed;if(!(p-m*(x-s)<=_))return[w,r]}return[-1,this.#e[0]]})();if(n===-1)return{start:-1,handle:-1};const k=this.#s,l={start:o.start,size:e,inuse:!0,user_enter_time:s,user_speed:t,clear_handle:k};return this.#s+=1,o.size>e?(o.start=o.start+e,o.size=o.size-e,this.#e.splice(n,0,l)):this.#e.splice(n,1,l),{start:l.start,handle:k}}free(e){let t=this.#e.findIndex(n=>n.inuse&&n.clear_handle===e);if(t===-1)return;t>0&&this.#e[t-1].inuse===!1&&(this.#e[t-1].size+=this.#e[t].size,this.#e.splice(t,1),t=t-1),t<this.#e.length-1&&this.#e[t+1].inuse===!1&&(this.#e[t].size+=this.#e[t+1].size,this.#e.splice(t+1,1));const s=this.#e[t];if(s.inuse===!0){const n={start:s.start,size:s.size,inuse:!1};this.#e.splice(t,1,n)}}}function ee(a,e,t){const s=U(t,e);for(const{element:i}of s)i.classList.add(S.danmaku,S[`danmaku-${a.shared.main_axis}-${a.shared.flow_direction}`]);const n=E({width:a.shared.scene_width,height:a.shared.scene_height},a.shared.main_axis),o=new X(n.breadth,a.shared.lift_duration,a.shared.enter_duration,n.length),k=[],l=[],w={exit_time:-1,animation:null};for(const{chat:i,element:_}of s){const p=i.shared.enter_millisecond;let x=0;for(const{exit_time:h,handle:$}of k){if(h>p)break;o.free($),x+=1}k.splice(0,x);const m=E({width:_.clientWidth,height:_.clientHeight},a.shared.main_axis),A=m.breadth+a.shared.chat_margin,R=m.length/a.shared.enter_duration,y=a.shared.enter_duration+n.length/R,C=p+y,{start:v,handle:z}=o.allocate(A,R,p);if(v===-1){console.log("failed to allocate track");continue}const f=a.shared.main_axis==="horizontal"?"translateX":"translateY",c=W(a.shared.flow_direction),j=a.shared.main_axis==="horizontal"?[{top:`${v}px`,transform:`${f}(${-c*m.length}px)`},{top:`${v}px`,transform:`${f}(${c*n.length}px)`}]:[{left:`${v}px`,transform:`${f}(${-c*m.length}px)`},{left:`${v}px`,transform:`${f}(${c*n.length}px)`}],L=new Animation(new KeyframeEffect(_,j,{duration:y,delay:p,fill:"forwards"}));l.push(L),k.push({exit_time:C,handle:z}),C>w.exit_time&&(w.exit_time=C,w.animation=L)}const r=Z(s,l,a);return{play:g(a.shared.delay_before_start,()=>{for(const i of l)i.play();return new Promise(i=>{w.animation.addEventListener("finish",()=>i())})},a.shared.keep_after_end,()=>{for(const i of l)i.cancel();for(const{element:i}of s)i.classList.remove(S.danmaku,S[`danmaku-${a.shared.main_axis}-${a.shared.flow_direction}`]);for(const i of r)i()})}}async function te(a,e,t){const s={width:e.shared.scene_width,height:e.shared.scene_height},n=new OffscreenCanvas(s.width,s.height),o=n.getContext("2d"),l=new OffscreenCanvas(0,0).getContext("2d"),w=e.shared.fps,r=1e3/w,i=Math.ceil(e.shared.delay_before_start/r);let _=Math.ceil((a.at(-1).shared.enter_millisecond+e.shared.enter_duration)/r);const p=Math.ceil(e.shared.keep_after_end/r);let x=i+_+p;const m=W(e.shared.flow_direction),A={x:e.shared.main_axis==="vertical"||e.shared.flow_direction==="inverse"?0:s.width,y:e.shared.main_axis==="horizontal"||e.shared.flow_direction==="inverse"?0:s.height},R={topleft:{x:0,y:0},bottomright:{x:s.width,y:s.height}},y=E(s,e.shared.main_axis),C=new X(y.breadth,e.shared.lift_duration,e.shared.enter_duration,y.length),v=await J.build(w,s);let z=0;{o.fillStyle=e.shared.background,o.fillRect(0,0,s.width,s.height);const h=await K(n);for(z=0;z<i;z++)await v.add_frame(h),t(z/x*100)}const f=a.map(h=>({chat:h,ccb:void 0,movement_controller:void 0,allocation_handle:void 0})),c={current_frame:0,current_time:0,time_delta:-1};for(;c.current_frame<p+_;c.current_time+=r,c.current_frame+=1,c.time_delta=r){const h=[];let $=0;for(const d of f){const{chat:b,ccb:O}=d;if(c.current_time<b.shared.enter_millisecond)break;if($+=1,O){h.push(d);continue}const u=await e.shared.selected_theme.prepare_rendering(b,e,l),P=u instanceof T?u.size:{height:u.render.height,width:u.render.width},M=E(P,e.shared.main_axis),q=M.breadth+e.shared.chat_margin,B=M.length/e.shared.enter_duration,{start:D,handle:F}=C.allocate(q,B,b.shared.enter_millisecond);if(D===-1){u instanceof T?await u.free():(u.render.close(),u.render_pass2?.image.close());continue}const H=b.shared.enter_millisecond+e.shared.enter_duration+y.length/B;d.movement_controller=new N({start:b.shared.enter_millisecond,end:H},{value:{start:0,end:M.length+y.length}});const G=Math.ceil(H/r);_=Math.max(_,G),x=Math.max(x,i+p+_),d.allocation_handle=F;const I=V({length:m===1?-M.length:0,breadth:D*m},e.shared.main_axis);d.ccb=new Q(u,{x:A.x+m*I.width,y:A.y+m*I.height}),h.push(d)}f.splice(0,$,...h.splice(0)),$=0;for(const d of f){const{ccb:b,allocation_handle:O,movement_controller:u}=d;if(b===void 0)break;$++;const P=V({length:u.get_value(c.current_time)*m,breadth:0},e.shared.main_axis);await b.update_position(P,R)?(await b.free(),C.free(O)):h.push(d)}f.splice(0,$,...h.splice(0)),o.fillStyle=e.shared.background,o.fillRect(0,0,s.width,s.height);for(const{ccb:d}of f){if(d===void 0)break;d.render(o,l,c)}for(const{ccb:d}of f){if(d===void 0)break;d.render_pass2(o,l,c)}const Y=await K(n);await v.add_frame(Y),z++,t(z/x*100)}for(const{ccb:h}of f)h!==void 0&&h.free();return(await(await v.close()).json()).name}const ne={name:"danmaku",display_name:"弹幕",preview:ee,render:te};export{ne as default};
